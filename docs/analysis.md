# 프로젝트 아키텍처 분석 및 유지보수 가이드

이 문서는 프로젝트의 아키텍처를 분석하고, 향후 유지보수 및 기능 추가 시 따라야 할 핵심 규칙과 개선이 필요한 설계적 약점을 기술합니다.

---

## 🎯 프로젝트 핵심 규칙 5가지

새로운 기능을 추가하거나 기존 코드를 수정할 때, 다음 5가지 규칙을 반드시 준수하여 코드의 일관성과 품질을 유지해야 합니다.

### **1. API 계층 규칙: `src/api`**

모든 서버 통신은 `src/api` 디렉토리 내에서 정의된 규칙을 따라야 합니다.

- **중앙 클라이언트 사용**: 모든 HTTP 요청은 `src/api/client.ts`에 정의된 `apiClient`를 사용해야 합니다. 직접 `axios`를 호출하지 마십시오.
- **도메인별 모듈화**: `exchanges.ts`, `users.ts`와 같이 기능(도메인)별로 파일을 분리하여 API 호출 함수를 관리합니다.
- **엄격한 타입 정의**: API 요청 및 응답에 대한 타입은 `src/api/types` 디렉토리 내에 해당 도메인 파일에 명확히 정의해야 합니다.
- **JSDoc 주석**: 새로 추가하는 모든 API 함수와 타입에는 JSDoc 형식의 주석을 작성하여 명세를 명확히 합니다.

### **2. 상태 관리 규칙: 훅(Hook)과 컨텍스트(Context)의 분리**

상태의 종류에 따라 정해진 방식을 사용해야 합니다.

- **서버 상태 (Data-fetching)**: `useAsyncState` 훅을 사용하여 `loading`, `data`, `error` 상태를 관리합니다. 컴포넌트 내에서 직접 `useState`로 로딩/에러 상태를 만들지 마십시오.
- **전역 UI 상태 (Theme, Modal 등)**: `context` 디렉토리에 React Context를 생성하고, 관련 `Provider`와 `Hook`을 만들어 사용합니다. `useTheme`이 좋은 예시입니다.
- **로컬/화면 상태**: `useState`, `useReducer` 등 React의 기본 훅을 사용하여 컴포넌트 또는 화면 내의 지역 상태를 관리합니다.

### **3. 컴포넌트 설계 규칙: 재사용성과 테마**

컴포넌트는 재사용성을 최우선으로 고려하여 설계해야 합니다.

- **범용 UI 컴포넌트**: 버튼, 카드, 입력창 등 앱 전역에서 사용되는 순수 UI 컴포넌트는 `components/ui`에 위치시킵니다.
- **테마 적용**: 모든 UI 컴포넌트는 `useTheme` 훅을 사용하여 색상, 폰트 등을 적용해야 합니다. 특정 색상 값을 하드코딩하지 마십시오.
- **화면(Screen) 컴포넌트**: Expo Router의 규칙에 따라 `app` 디렉토리 내에 라우팅 경로에 맞게 배치합니다. 화면 컴포넌트는 UI 컴포넌트를 조합하고 비즈니스 로직을 처리하는 역할을 담당합니다.

### **4. 타입 시스템 규칙: `types` 디렉토리 활용**

타입 정의는 정해진 위치에 명확하게 작성해야 합니다.

- **공통 타입**: `BaseApiResponse`, `AsyncState`와 같이 앱 전반에서 사용되는 범용 타입은 `src/types/common.ts`에 정의합니다.
- **도메인 타입**: API 응답 모델과 같이 특정 기능(도메인)에 종속적인 타입은 `src/api/types` 내에 파일을 분리하여 정의합니다.
- **`interface`와 `type`**: 객체 형태는 `interface`, 유니온이나 별칭은 `type`을 사용하는 기존 컨벤션을 따릅니다.

### **5. 커스텀 훅(Hook) 규칙: 로직 추상화**

두 번 이상 사용되거나 복잡한 비즈니스 로직, 상태 로직은 반드시 커스텀 훅으로 분리해야 합니다.

- **위치**: 모든 커스텀 훅은 `src/hooks` 디렉토리에 위치시킵니다.
- **명명법**: 훅의 이름은 `use` 접두사로 시작해야 합니다. (예: `usePagination`)
- **역할**: 훅은 컴포넌트의 렌더링 로직과 비즈니스 로직을 분리하여 테스트 용이성과 재사용성을 높이는 데 목적이 있습니다. `useAsyncState`, `useWebSocket`이 좋은 예시입니다.

---

## 🧐 설계적 약점 및 개선 제안

현재 아키텍처는 매우 견고하지만, 전역 상태 관리 전략의 일관성 측면에서 개선할 수 있는 부분이 존재합니다.

### **문제점: 인증 상태 관리의 불일치**

- **현상**: 현재 인증 상태(`user` 정보)는 `useAuth`라는 커스텀 훅 내부의 `useState`로 관리되고 있습니다. 이 훅은 **React Context를 사용하지 않기 때문에**, 이 훅을 호출하는 컴포넌트들은 **상태를 공유하지 않고 각자 독립적인 상태**를 갖게 됩니다.
- **잠재적 위험**: 예를 들어, 앱의 헤더와 프로필 화면이 각각 `useAuth` 훅을 호출하고 있을 때, 프로필 화면에서 로그아웃을 하더라도 헤더는 그 변화를 즉시 감지하지 못하는 상태 불일치 문제가 발생할 수 있습니다. 이는 사용자 경험에 혼란을 줄 수 있습니다.

### **개선 제안: `AuthContext` 도입**

- **해결책**: `useAuth` 훅을 **React Context 기반으로 리팩토링**하여 인증 상태를 진정한 '전역' 상태로 만드는 것을 권장합니다.
- **실행 방안**:
  1. `context/AuthContext.tsx` 파일을 생성하여 `AuthContext`와 `AuthProvider` 컴포넌트를 정의합니다.
  2. `AuthProvider` 내부에 기존 `useAuth` 훅의 상태 관리 로직(`useState`, `signin`, `signout` 등)을 이전합니다.
  3. `app/_layout.tsx`의 최상단을 `AuthProvider`로 감싸 앱 전역에 인증 상태를 제공합니다.
  4. `useAuth` 훅은 `useContext(AuthContext)`를 호출하여 전역 상태를 소비(consume)하는 간단한 형태로 수정합니다.

- **기대 효과**: 이 리팩토링을 통해 앱의 모든 컴포넌트가 **단일 소스(Single Source of Truth)의 인증 상태를 공유**하게 되어, 상태 불일치 문제를 원천적으로 차단하고 더욱 안정적이고 예측 가능한 애플리케이션을 만들 수 있습니다.
