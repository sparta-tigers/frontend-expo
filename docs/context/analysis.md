# 🏗️ FSD 아키텍처 기반 프로젝트 가이드

이 문서는 Feature-Sliced Design (FSD) 아키텍처로 리팩토링된 프로젝트의 구조와 핵심 규칙을 기술합니다. Phase 2 완료 기준으로 작성되었습니다.

---

## 🎯 FSD 아키텍처 핵심 규칙 5가지

새로운 기능을 추가하거나 기존 코드를 수정할 때, 다음 5가지 규칙을 반드시 준수하여 코드의 일관성과 품질을 유지해야 합니다.

### **1. API 계층 규칙: `src/features/*/api`**

모든 서버 통신은 FSD 아키텍처의 `api` 슬라이스를 따라야 합니다.

- **중앙 클라이언트 사용**: 모든 HTTP 요청은 `src/core/client.ts`에 정의된 `apiClient`를 사용해야 합니다. 직접 `axios`를 호출하지 마십시오.
- **도메인별 모듈화**: `src/features/auth/api.ts`, `src/features/exchange/api.ts`와 같이 기능(도메인)별로 파일을 분리하여 API 호출 함수를 관리합니다.
- **엄격한 타입 정의**: API 요청 및 응답에 대한 타입은 각 도메인의 `types.ts` 파일에 명확히 정의해야 합니다.
- **JSDoc 주석**: 새로 추가하는 모든 API 함수와 타입에는 JSDoc 형식의 주석을 작성하여 명세를 명확히 합니다.

### **2. 상태 관리 규칙: 훅(Hook)과 컨텍스트(Context)의 분리**

상태의 종류에 따라 정해진 방식을 사용해야 합니다.

- **서버 상태 (Data-fetching)**: `useAsyncState` 훅을 사용하여 `loading`, `data`, `error` 상태를 관리합니다. 컴포넌트 내에서 직접 `useState`로 로딩/에러 상태를 만들지 마십시오.
- **전역 UI 상태 (Theme, Modal 등)**: `context` 디렉토리에 React Context를 생성하고, 관련 `Provider`와 `Hook`을 만들어 사용합니다. `useTheme`, `useAuth`이 좋은 예시입니다.
- **로컬/화면 상태**: `useState`, `useReducer` 등 React의 기본 훅을 사용하여 컴포넌트 또는 화면 내의 지역 상태를 관리합니다.

### **3. 컴포넌트 설계 규칙: 재사용성과 테마**

컴포넌트는 재사용성을 최우선으로 고려하여 설계해야 합니다.

- **범용 UI 컴포넌트**: 버튼, 카드, 입력창 등 앱 전역에서 사용되는 순수 UI 컴포넌트는 `components/ui`에 위치시킵니다.
- **테마 적용**: 모든 UI 컴포넌트는 `useTheme` 훅을 사용하여 색상, 폰트 등을 적용해야 합니다. 특정 색상 값을 하드코딩하지 마십시오.
- **화면(Screen) 컴포넌트**: Expo Router의 규칙에 따라 `app` 디렉토리 내에 라우팅 경로에 맞게 배치합니다. 화면 컴포넌트는 UI 컴포넌트를 조합하고 비즈니스 로직을 처리하는 역할을 담당합니다.

### **4. 타입 시스템 규칙: FSD 기반 타입 관리**

타입 정의는 FSD 아키텍처의 명확한 위치에 작성해야 합니다.

- **공통 타입**: `ApiResponse`, `AsyncState`와 같이 앱 전반에서 사용되는 범용 타입은 `src/shared/types/common.ts`에 정의합니다.
- **도메인 타입**: API 응답 모델과 같이 특정 기능(도메인)에 종속적인 타입은 `src/features/*/types.ts` 내에 정의합니다.
- **`interface`와 `type`**: 객체 형태는 `interface`, 유니온이나 별칭은 `type`을 사용하는 기존 컨벤션을 따릅니다.

### **5. 커스텀 훅(Hook) 규칙: 로직 추상화**

두 번 이상 사용되거나 복잡한 비즈니스 로직, 상태 로직은 반드시 커스텀 훅으로 분리해야 합니다.

- **위치**: 모든 커스텀 훅은 `src/hooks` 디렉토리에 위치시킵니다.
- **명명법**: 훅의 이름은 `use` 접두사로 시작해야 합니다. (예: `usePagination`)
- **역할**: 훅은 컴포넌트의 렌더링 로직과 비즈니스 로직을 분리하여 테스트 용이성과 재사용성을 높이는 데 목적이 있습니다. `useAsyncState`, `useWebSocket`, `useAuth`이 좋은 예시입니다.

---

## 🏗️ FSD 아키텍처 구조

### **디렉토리 계층**

```
src/
├── core/               # 핵심 기능 (client.ts)
├── shared/             # 공용 리소스
│   ├── types/          # 공통 타입 (common.ts)
│   └── hooks/          # 공용 훅 (useAsyncState.ts)
├── features/           # 도메인별 기능
│   ├── auth/           # 인증 기능
│   │   ├── api.ts      # 인증 API
│   │   ├── types.ts    # 인증 타입
│   │   └── hooks.ts    # 인증 훅
│   ├── exchange/       # 교환 기능
│   │   ├── api.ts      # 교환 API
│   │   ├── types.ts    # 교환 타입
│   │   └── items.ts    # 아이템 관련
│   └── chat/           # 채팅 기능
│       ├── api.ts      # 채팅 API
│       └── types.ts    # 채팅 타입
├── hooks/              # 전역 훅
├── utils/              # 유틸리티
└── constants/          # 상수 (unified-design.ts)
```

### **FSD 슬라이스 규칙**

- **api**: 서버와의 통신 로직
- **types**: 도메인별 타입 정의
- **hooks**: 도메인별 커스텀 훅
- **entities**: (향후) 비즈니스 엔티티
- **model**: (향후) 비즈니스 로직

---

## 🧐 현재 아키텍처 강점

### **✅ 완벽한 도메인 분리**

- 각 기능이 독립적인 슬라이스로 구성됨
- 도메인 간 의존성이 최소화됨
- 코드 재사용성과 테스트 용이성 확보

### **✅ 타입 안정성**

- TypeScript Strict Mode 완벽 준수
- 모든 API 응답과 상태에 타입 정의
- `npx tsc --noEmit` 0 에러 달성

### **✅ 중앙 관리 시스템**

- 공용 타입과 훅의 중앙 집중 관리
- 절대 경로(`@/`) 일관성 확보
- 단일 진실 공급원(SSOT) 구축

### **✅ 인증 상태 관리**

- `AuthContext` 기반 전역 상태 관리
- `useAuth` 훅을 통한 일관된 상태 접근
- 상태 불일치 문제 완전 해결

---

## 🚀 Phase 3 준비 상태

FSD 아키텍처 기반으로 Phase 2가 완벽하게 완료되어 Phase 3 UI 컴포넌트 재구현을 위한 견고한 기반이 마련되었습니다.

### **기술적 준비 완료**

- ✅ 타입 안정성 100% 보장
- ✅ 확장 가능한 아키텍처
- ✅ 깔끔한 코드 구조
- ✅ 일관된 import 시스템

### **다음 단계**

- Phase 3: UI 컴포넌트 재구현
- Phase 4: 성능 최적화
- Phase 5: 테스트 자동화

---

*작성일: 2026-02-27*  
*기반: Phase 2 FSD 아키텍처 완료*  
*상태: 최신*
